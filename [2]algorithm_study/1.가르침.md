# 문제 
    남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.

    남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.

    출처 https://www.acmicpc.net/problem/1062








# 문제를 마주하고 갖은 생각
    1. 입력되는 string을 slicing을 이용해 중간 부분만 남겨서 처리할 수 있다.
    a, n, t, i, c 라는 alphabet은 무조건 포함이 되어야만 글자를 읽을 수가 있다. 그것을 제외한 나머지 alphabet중 어떤 것을 포항해야 할 지 결정하면 된다. 
    
    
    2. N, K의 크기가 크지 않다.
    따라서 전체에 대한 combination이나 순회을 해볼수도 있겠다는 생각을 가졌다.


    3. 전체 입력되는 문자열들에서 가장 많이 나온 순서대로(빈도로) 나열해볼까?
    답은 아마 순서대로 나열되었을 때 앞쪽의 alphabet의 조합에서 나오게 될 가능성이 매우 크다. 따라서 순서대로 나열 해 보는 것이 의미 있을 수 있다고 생각했다.
    다만, 한 문자열 안에서 중복되는 alphabet은 의미가 없다는 것과, 순서대로 나열 했다고 바로 정답이 나오지는 않는다는 것을 빨리 파악할 필요가 있었다.

    
    4. 그럼 alphabet의 빈도 순서대로 나타내고 그 상태에서 순회를 해볼까?
    만약 전체 알파벳중 3개를 택해야 한다고 하자. 그럼 가장 앞쪽에서 2개, 뒤쪽에서 1개를 뽑는 것 보다는, 적당히 앞쪽에 있는 3개는 뽑는 것이 더 유리할 것이다. 전체 순회의 순서를 정해주는 것이 생각보다 어려울 수 있다.
    또한 전체 순회를 하지 않고 최대값임을 확신하며 순회를 멈출 수 있는 조건은 무엇이 있을 지에 대한 생각도 필요하다.


# code






        
# 문제를 풀며 막혔던 부분
    1. 어떻게 저장해야 할까?
    26개의 alphabet에 대한 리스트를 생성하고 진행하고자 했다. a가 0번째, b가 1번재... 만약 이렇게 하고 sort를 한다면 몇번째 값이 어떤 문자인지 알 수 없다. 따라서 어떠한 문자가 몇번 나왔는지 두 값을 같이 갖고 있어야한다.
    또한 진행하다보면 현재 어떤 alphabet들이 이번 순회에서 선택된 alphabet들인지를 알아야 하는데 그것을 boolean type으로 같이 저장해줄 필요가 있었다.
    따라서 alphabet_list = [[i, 0, False] for i in range(26)] 과 같이 선언하고 사용하는 것이 편리하다. class를 통해 구현하는 것이 좋겠지만 처리가 빠를 것 같지 않았다.

    2. dfs는 어떻게 구현해야 할까?
       1. input으로 무엇을 줘야 할까?
        나는 시작위치와 깊이를 줘야 한다고 생각했다. 시작위치를 통해 지나온 값들에 대해서는 순회하지 않을 수 있고 깊이를 통해 말단노드에 도착했음을 알 수 있다.

       2. 말단 노드에 도착했다는 조건은 어떻게 줄까?
        말단 노드에 도착했다는 조건은 깊이를 통해 알려줄 수 있다. a, n, t, i, c를 제외한 선택된 알파벳의 개수가 깊이가 된다. 원하는 알파벳의 개수만큼 포함시켰을 때 말단 노드에서 실행해야 할 것을 실행하면 된다.

       3. 말단 노드에 도착했을 때 실행해야 하는 것은 무엇인가?
        이 경우에서는 선택한 알파벳들으 이용하여 만들 수 있는 문자열의 개수를 카운트 하면 된다.

       4. 순회는 어떻게 진행되는가?
        시작 위치를 옮겨줌으로써 다음 번 순회가 가능하도록 한다.
        조금 애매하긴 하지만 코드의 dfs(start+1, end)를 보면 무엇을 뜻하고자 하는 지 알 수 있을 것이다.


    3. 문자 비교는 for문을 돌 수밖에?
    string이 iterable하다는 것을 이용해서 쉽게 비교할 수 있었다. 그러나 매번 배열에 접근해야 했고 모든 문자열의 모든 문자에 대한 검사가 필요했다. 이것을 빠르게 처리할 방법이 이것밖에 없는지 고민해보았다.

    4. 빈도대로 정렬 되어 있을 때 가장 답을 빨리 찾을 수 잇는 방법으로 dfs를 진행하는 방법은 무엇일까?
    이것에 대한 답은 잘 모르겠다. 짧은 생각으로는 dfs에서 포함된 알파벳의 빈도수를 더해서 큰 값들 먼저 진행하는 것이 좋을 것 같다. 그러나 더해서 큰 값들을 구해놓고 진행하는 것은 dfs를 진행하는것과 마찬가지이다. 내가 생각한 것은 큰 순서로 정렬 되어 있고 3가지를 뽑는다고 했을때 (1,2,3), (1,2,4), (1,2,5)이렇게 순서대로 진행하면서 (2,3,4)가 더 커지는 순간이 있을 것이고 그때 (2,3,4)를 진행하면서 또 다른 값들과 비교를 진행하는 것인데 좀 어려운 것 같다.

    5. 중간에 dfs의 진행을 멈출 부분은 없는가? ★★★★★
    있다. 내가 생각한 부분은 만약 리스트의 어떤 원소의 빈도가 max보다 작다면 그것은 계산해볼 필요가 없다. 

# 배운 부분
    1. Combination은 자식 노드의 개수가 줄어드는 트리로 나타낼 수 있다.


    2. DFS vs BFS
    처음에 combinations()를 이용하여 하려고 시도했을 때 메모리가 부족했다. 그래서 조합을 미리 생성할 것이 아니라 하나씩 순회하면서 해결하는 것은 가능할 것이라고 생각했다. 그러면서 DFS, BFS 뭐가 유리할지 생각했다.
    DFS는 메모리에 depth 만큼이 쌓인다. 반면 BFS는 이 경우 메모리에 위의 트리 전체가 쌓인다. 여기서는 DFS를 통해 진행하는 것이 메모리면에서 확실히 유리하다. 
    


# 풀이에 대한 review

    dfs를 중간에 중단할 수 있는 부분을 찾아봤다는 점이 다른 사람들과 다르다. 물론 최적의 방법은 아닌 것 같다
    
    문자열이 선택된 알파벳으로 조합될 수 있는지에 대해서는 &를 이용하는 사람들의 풀이를 배울 수 있었다.


