# 백준_11047_동전0_그리디

문제 
    준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

    동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오..

입력

    첫째 줄에 N과 K가 주어진다. 
    둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. 



출력

    첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.


제한

    (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
    (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)


답
```python
n, k = map(int,input().split())

coin = []
result = 0

for i in range(n):
    coin.append(int(input()))

for i in range(n):
    result += (k // coin[n-i-1])
    k = k % coin[n-i-1]
    
print(result)
```


      
방법
    
    그리디 알고리즘을 처음 배울 때 언급되는 동전 문제이다.
    가장 단위가 큰 동전을 낼 수 있으면 그렇게 하는 것이 가장 유리하다.

    여기서 조금 중요한 것은 제한에 있는 조건이다.
    Ai는 Ai-1의 배수라는 조건 때문에 그리디 알고리즘을 사용할 수 있다.
    그리디 알고리즘을 사용할 때는 그리디 알고리즘이 최적을 보장한다는 확신이 있어야 한다.


    

시간 복잡도
    
    동전의 개수 N개에 대해서 몫과 나머지를 구해가며 구하면 되기 때문에 
    시간 복잡도는 O(n)이다.
        
    
배워가는 점
    
    코드가 어렵게 작성되지 않았고 쉽게 풀었다.

    다른 사람의 코드를 보니 두번째 for문 에서
    for i in coin = [::-1] 과 같이 값에 바로 접근을 할 수 있었다.
    
    list slicing 할때
    list[start : end : step] 인것은 알고 있었다.
    그래서 list[::-1]을 하면 reverse 같은 기능이다.
    
    myList = ['a', 'b', 'c', 'd', 'e']
    d, c 순으로 출력하고 싶다면
    myList[3], myList[2]를 출력하는 것이므로 print(myList[3:1:-1])와 같이 작성하면된다.

