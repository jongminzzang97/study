# 제목

문제 

    https://www.acmicpc.net/problem/2579
    문제가 길어 링크로 대체한다.
    
입력

    입력의 첫째 줄에 계단의 개수가 주어진다.

    둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다.
    계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.



출력

    첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.




답
```python
# 내 답안 
N = int(input())
X = [int(input()) for _ in range(N)]
ans = [[-1 for _ in range(N)] for _ in range(2)]



def get_max(end):
    if end == 1:
        return X[0]
    
    if end == 2:
        return X[0] + X[1]
    
    ans[0][0] = 0
    ans[1][0] = X[0]
    
    ans[0][1] = X[1]
    ans[1][1] = X[0] + X[1]
    
    
    
    for i in range(2,N):
        ans[0][i] = ans[1][i-2] + X[i]
        ans[1][i] = max(ans[0][i-1], ans[1][i-2]) + X[i]
    
    return max(ans[0][end-1], ans[1][end-1])


print(get_max(N))


# 참고할만한 답안

```

방법 및 배워가는 점
    
    DP를 공부하고 처음 선택하여 푼 문제이다.
    전형적인 DP문제이지만 1칸씩 연속하여 올라갈 수 없다는 제약조건 때문에 조금 어려웠다.

    확실하게 느낀 것은
    DP문제가 어려운 이유는 점화식을 세우기가 어려워서이다.

    =============================================================================

    내가 푼 방법은
    ans[0][i]에 i번째 칸에 도달할 때 마지막으로 2칸을 이용하여 도달한 것을 저장하고,
    ans[1][i]는 i번째 칸에 도달할 때 마지막으로 어떻게 도달했는지 상관없이 최대가 되는 값을 저장했다.

    ans[0][k]는 1칸 또는 2칸을 갈 수 있지만     
    ans[1][k]는 다음에는 무조건 2칸을 갈 수 밖에 없다.

    그래서 나는 점화식을 다음과 같이 작성하였다.
    ans[0][i] = ans[1][i-2] + X[i]
    ans[1][i] = max(ans[0][i-1], ans[1][i-2]) + X[i]


    =============================================================================

    일단 풀 때는 최대한 빨리 풀어야 하기 때문에 그냥 풀었지만 풀이가 나서 썩 만족스럽진 않았다.
    배열을 하나로 둘 수 있을 것 같아서 조금 찾아보니 조금 더 좋은 풀이를 찾을 수 있었다.
    
    dp[n] = dp[i-2] + arr[i]                
    dp[n] = dp[i-3] + arr[i-1] + arr[i]
    
    i번째 칸에 최대값으로 도달하기 위해서는
    전전칸까지의 최대에서 한번에 오는 것이나
    전전전칸에서 두칸 한칸 오는 것이다. (이 부분을 스스로 이해해 보는 것이 중요하다.)
    (전전칸에서의 한칸 한칸을 오는 것은 불가능 하다.
    따라서 전칸에서 한칸을 이동하였다는 것은 전전전칸에서 두칸 전칸에서 한칸을 이동하였다는 것이다.) 

    =============================================================================
    
    일단 풀때는 어떻게든 점화식을 빨리 찾아서 풀고
    다 푼 뒤에는 조금 더 깔끔한 점화식이 없을지를 생각해보는 것이 도움이 될 것 같다.
    

    
    
    

시간 복잡도
    
    n번째 칸까지의 배열을 채우기만 하면 되기에 시간 복잡도는 O(n)이다.



